# -*- coding: utf-8 -*-
###############################################################################
# Copyright (c), Forschungszentrum JÃ¼lich GmbH, IAS-1/PGI-1, Germany.         #
#                All rights reserved.                                         #
# This file is part of the AiiDA-SPEX package.                               #
#                                                                             #
# The code is hosted on GitHub at https://github.com/JuDFTteam/aiida-spex     #
# For further information on the license, see the LICENSE.txt file            #
# For further information please visit http://www.flapw.de or                 #
###############################################################################

"""
This module contains the parser for a spex calculation and methods for
parsing different files produced by inpgen.
"""
from aiida.parsers import Parser
from aiida.orm import Dict
from aiida.common.exceptions import NotExistent
from aiida_spex.calculations.spex import SpexCalculation

from aiida_spex.tools.spex_io import spexout_parser
from aiida_spex.tools.add_parsers import parser_registry, spexfile_parse
import re


class SpexParser(Parser):
    def get_linkname_outparams(self):
        """
        Returns the name of the link to the output_complex
        Node contains the SPEX output in a rather complex dictionary.
        """
        return "output_parameters"

    def get_linkname_outparams_add(self):
        """
        Returns the name of the link to the output_add
        Node contains the SPEX output corresponding to the given additional parser.
        """
        return "output_parameters_add"

    def parse(self, **kwargs):
        """
        Takes spex.out generated by SPEX calculation and created data node.

        :return: a dictionary of AiiDA nodes to be stored in the database.
        """
        calc = self.node  # type: SpexCalculation
        SpexCalculation = calc.process_class

        should_retrieve = calc.get_attribute("retrieve_list")

        has_spex_outfile = False
        has_inpxml_file = False

        try:
            output_folder = self.retrieved
        except NotExistent:
            self.logger.error("No retrieved folder found")
            return self.exit_codes.ERROR_NO_RETRIEVED_FOLDER

        # check what is inside the folder
        list_of_files = output_folder.list_object_names()
        self.logger.info("file list {}".format(list_of_files))

        self.logger.info("SpexData initialized")

        if SpexCalculation._OUTPUT_FILE_NAME not in list_of_files:
            self.logger.error(
                f"SPEX out not found '{SpexCalculation._OUTPUT_FILE_NAME}'"
            )
            has_spex_outfile = False  # Return after the error lines were processed
        else:
            has_spex_outfile = True

        for file in should_retrieve:
            if file not in list_of_files:
                self.logger.warning(
                    f"Expected file '{file}' not found in retrieved folder, it was probably not created by fleur or spex"
                )

        if SpexCalculation._ERROR_FILE_NAME in list_of_files:
            errorfile = SpexCalculation._ERROR_FILE_NAME
            # read
            try:
                with output_folder.open(errorfile, "r") as efile:
                    error_file_lines = efile.read()  # Note: read(), not readlines()
            except OSError:
                self.logger.error(f"Failed to open error file: {errorfile}.")
                return self.exit_codes.ERROR_OPENING_OUTPUTS
            if error_file_lines:
                spex_error = re.findall(r"SPEX-ERROR.*", error_file_lines)

                if spex_error:
                    self.logger.error(f"SPEX error: {spex_error}")
                    return self.exit_codes.ERROR_SPEX_CALC_FAILED

        with output_folder.open(
            SpexCalculation._OUTPUT_FILE_NAME, "r"
        ) as spexout_opened:
            success = True
            parser_info = {}
            try:
                out_dict = spexout_parser(spexout_opened.read())
            except (ValueError, FileNotFoundError, KeyError) as exc:
                self.logger.error(f"output parsing failed: {str(exc)}")
                success = False

        # Call routines for output node creation
        if not success:
            self.logger.error("Parsing of SPEX  output file was not successfull.")
            spexout_params = Dict(dict=parser_info)
            link_name = self.get_linkname_outparams()
            self.out(link_name, spexout_params)
            return self.exit_codes.ERROR_SPEXOUT_PARSING_FAILED
        elif out_dict:
            spexout_params = Dict(dict={**out_dict, **parser_info})
            link_name = self.get_linkname_outparams()
            self.out(link_name, spexout_params)
        else:
            self.logger.error("Something went wrong, no out_dict found")
            spexout_params = Dict(dict=parser_info)
            link_name = self.get_linkname_outparams()
            self.out(link_name, spexout_params)

        # Additional parsers

        add_parser_list = calc.inputs.settings.get_dict()["parsers"]
        if add_parser_list:
            add_dict = {}
            for parser_name in add_parser_list:
                add_filename = parser_registry[parser_name]
                if add_filename in list_of_files:
                    try:
                        with output_folder.open(add_filename, "r") as add_file:
                            add_dict_t = spexfile_parse(
                                parser_name, out_dict, add_file.read()
                            )
                            add_dict[parser_name] = add_dict_t
                    except OSError:
                        self.logger.error(f"Failed to open error file: {errorfile}.")
                        return self.exit_codes.ERROR_OPENING_OUTPUTS
                else:
                    self.logger.error(f"File {add_filename} not found")
                    return self.exit_codes.ERROR_SPEXOUT_PARSING_FAILED
            if add_dict:
                add_params = Dict(dict=add_dict)
                link_name = self.get_linkname_outparams_add()
                self.out(link_name, add_params)
            else:
                self.logger.error("Something went wrong, no add_dict found")
                add_params = Dict(dict=add_dict)
                link_name = self.get_linkname_outparams_add()
                self.out(link_name, add_params)
